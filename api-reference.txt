1:HL["/_next/static/css/369a28591c129e58.css",{"as":"style"}]
0:["DoTCcjqYEhWzV1jJmxkjY",[[["",{"children":["(layout)",{"children":["api-reference",{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/369a28591c129e58.css","precedence":"next"}]],["$L3",null]]]]]
4:HL["/_next/static/css/96e77edbf29b84fb.css",{"as":"style"}]
5:HL["/_next/static/css/c580934e13ef668d.css",{"as":"style"}]
6:I{"id":68576,"chunks":["518:static/chunks/518-a76d3f16b9160eac.js","185:static/chunks/app/layout-baaebcfe35cc36f5.js"],"name":"","async":false}
7:I{"id":77002,"chunks":["518:static/chunks/518-a76d3f16b9160eac.js","185:static/chunks/app/layout-baaebcfe35cc36f5.js"],"name":"","async":false}
8:I{"id":13211,"chunks":["272:static/chunks/webpack-edbb62be5043ebfd.js","253:static/chunks/bce60fc1-6a16359ba0706bd8.js","769:static/chunks/769-6148ae0eb33a06a1.js"],"name":"default","async":false}
9:I{"id":5767,"chunks":["272:static/chunks/webpack-edbb62be5043ebfd.js","253:static/chunks/bce60fc1-6a16359ba0706bd8.js","769:static/chunks/769-6148ae0eb33a06a1.js"],"name":"default","async":false}
a:I{"id":39997,"chunks":["79:static/chunks/1418ae87-3000290110e18c25.js","296:static/chunks/2e3a737e-571b0c8472a5afbb.js","518:static/chunks/518-a76d3f16b9160eac.js","88:static/chunks/88-548fbfdb138ebe53.js","540:static/chunks/app/(layout)/layout-025a0c59bd89f76c.js"],"name":"","async":false}
b:I{"id":54471,"chunks":["79:static/chunks/1418ae87-3000290110e18c25.js","296:static/chunks/2e3a737e-571b0c8472a5afbb.js","518:static/chunks/518-a76d3f16b9160eac.js","88:static/chunks/88-548fbfdb138ebe53.js","540:static/chunks/app/(layout)/layout-025a0c59bd89f76c.js"],"name":"","async":false}
c:I{"id":82924,"chunks":["518:static/chunks/518-a76d3f16b9160eac.js","24:static/chunks/24-d7a24ba30ab0b1ae.js","780:static/chunks/780-ddfd853e4a4c7a71.js","392:static/chunks/app/(layout)/api-reference/page-bd75294ae55b6f09.js"],"name":"","async":false}
d:I{"id":87067,"chunks":["79:static/chunks/1418ae87-3000290110e18c25.js","296:static/chunks/2e3a737e-571b0c8472a5afbb.js","518:static/chunks/518-a76d3f16b9160eac.js","24:static/chunks/24-d7a24ba30ab0b1ae.js","780:static/chunks/780-ddfd853e4a4c7a71.js","287:static/chunks/app/(layout)/(presentation)/(page)/page-5e5e9a672691ead2.js"],"name":"","async":false}
e:I{"id":71043,"chunks":["79:static/chunks/1418ae87-3000290110e18c25.js","296:static/chunks/2e3a737e-571b0c8472a5afbb.js","518:static/chunks/518-a76d3f16b9160eac.js","88:static/chunks/88-548fbfdb138ebe53.js","540:static/chunks/app/(layout)/layout-025a0c59bd89f76c.js"],"name":"","async":false}
f:I{"id":28463,"chunks":["79:static/chunks/1418ae87-3000290110e18c25.js","296:static/chunks/2e3a737e-571b0c8472a5afbb.js","518:static/chunks/518-a76d3f16b9160eac.js","88:static/chunks/88-548fbfdb138ebe53.js","540:static/chunks/app/(layout)/layout-025a0c59bd89f76c.js"],"name":"","async":false}
2:[["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","meta",null,{"name":"google-site-verification","content":"XEy7NkRYOuOexcZuyLjHgnyVm_gfzYwXuH87ZvesxzM"}],["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1, shrink-to-fit=no"}],["$","link",null,{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=Roboto"}],["$","link",null,{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=Source+Code+Pro"}]]}],["$","body",null,{"children":["$","$L6",null,{"children":["$","$L7",null,{"value":{"size":"2em"},"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[[["$","$La",null,{"minWidth":850,"children":["$","div",null,{"className":"layout_appContainer__lBmos","children":[["$","$Lb",null,{}],["$","div",null,{"className":"layout_pageContent__3qZXW","children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(layout)","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(layout)","children","api-reference","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[["$","$Lc",null,{"children":[["$","$Ld",null,{"children":"The library exports two functions and a typescript type: *getHookAndProviderFromSlices*, *defineSlice*, and *ReduxMiddleware*. *getHookAndProviderFromSlices* is the main function exported and it's a default export. *defineSlice* it's a function only used in typescript."}],["$","div",null,{"children":["$","$Ld",null,{"className":"page_table__6JVk5","children":"\n<table><tr><th>Name</th><th>Type</th><th style=\"min-width:400px;\">Description</th><th>Example</th></tr>\n<tr><td>\n  \n  *getHookAndProviderFromSlices* (default import)</td><td>\n\n ~~~ts\n (config: {\n  slices?: {\n    [slice: string]: Slice<any, any>;\n  };\n  AsyncStorage?: any;\n  reduxStoreOptions?: {\n    middleware:\n      | ((getDefaultMiddleware: any) => MiddlewareArray)\n      | MiddlewareArray;\n  };\n}) => {\n  useSlice: (<T, K = T>(\n    slice: string,\n    selector: (state: T) => K\n  ) => [K, ReduxDispatch<AnyAction>, { [x: string]: any }]) &\n    (<T, K = T>(\n      slice: string\n    ) => [\n      K,\n      SetValue<T> & Dispatch & ReduxDispatch<AnyAction>,\n      { [x: string]: any }\n    ]);\n  Provider: ContextProviderType;\n}\n ~~~\n  </td><td>\n    \n  It is the main (and default) function exported by the library. You pass a config object with optional keys *slices*, *AsyncStorage*, and *reduxStoreOptions*. The *slices* key is an object wich its keys are the slices names and its values, the defintion of the slices.</td><td>\n    \n~~~js\nimport getHookAndProviderFromSlices from \"react-context-slices\";\n\nexport const { useSlice, Provider } = getHookAndProviderFromSlices({\n  slices: {\n    count: { initialArg: 0 }, // React Context slice\n  },\n});\n~~~\n</td></tr><tr><td>\n\n*defineSlice* (used in typescript)\n  </td><td>\n    \n~~~ts\n<T, K = T>(slice: Slice<T, K>) => Slice<T, K>;\n~~~\n</td><td>\n  \n  This function enforces rules for types in the definition of a slice object. It's a generic function.</td><td>\n    \n~~~ts\nimport getHookAndProviderFromSlices, {defineSlice} from \"react-context-slices\";\n\nexport const { useSlice, Provider } = getHookAndProviderFromSlices({\n  slices: {\n    count: defineSlice<number>({ initialArg: 0 }), // React Context slice\n  },\n});\n~~~\n</td></tr><tr><td>\n  \n*ReduxMiddleware* (typescript type)\n</td><td>\n  \n~~~ts\n(store: {\n  getState: () => any;\n  dispatch: ReduxDispatch<AnyAction>;\n}) => (next: ReduxDispatch<AnyAction>) => (action: AnyAction) => void;\n~~~\n</td><td>\n  \nIs the type against to make an assertion in typescript when defining middleware in *reduxStoreOptions*\n</td><td>\n  \n~~~ts\nimport getHookAndProviderFromSlices, {defineSlice, ReduxMiddleware} from \"react-context-slices\";\n\nexport const {useSlice, Provider} = getHookAndProviderFromSlices({\n  slices:{\n    //...\n  },\n  reduxStoreOptions: {\n    middleware: (getDefaultMiddleware) =>\n      getDefaultMiddleware().concat(((store) => (next) => (action) => {\n        //...\n      }) as ReduxMiddleware);\n  }\n});\n~~~\n</td></tr>\n</table>\n"}]}],["$","$Ld",null,{"children":"Next are described other entities encountered when using this library."}],["$","div",null,{"children":["$","$Ld",null,{"className":"page_table__6JVk5","children":"\n<table><tr><th>Name</th><th>Type</th><th style=\"min-width:400px;\">Description</th><th>Example</th></tr>\n<tr><td>config object</td><td>\n  \n~~~ts\n{\n  slices?: {\n    [slice: string]: Slice<any, any>;\n  };\n  AsyncStorage?: any;\n  reduxStoreOptions?: {\n    middleware?:\n      | ((getDefaultMiddleware: any) => MiddlewareArray)\n      | MiddlewareArray;\n    devTools?: any;\n    preloadedState?: any;\n    enhancers?: any;\n  };\n}\n~~~\n</td><td>\n  \nIt's the object passed to *getHookAndProviderFromSlices*. It can contain three optional keys: *slices*, *AsyncStorage*, and *reduxStoreOptions*.\n</td><td>\n  \n~~~js\n{\n  slices: {\n    //...\n  }\n}\n~~~\n</td></tr><tr><td>\n  \nslices object\n</td><td>\n  \n~~~ts\n{\n  [name:string]: Slice<T, K>;\n}\n~~~ \n</td><td>\n  \nThe slices object is an object which its keys are the name of the slices and its values are the slices themselves.\n</td><td>\n  \n~~~js\n{\n  count: {initialArg: 0}, // React Context slice\n  todos: { \n    // Redux slice\n    initialState: [],\n    reducers: {\n      add: (state, {payload}) => {\n        state.push(payload);\n      }\n    }\n  }\n}\n~~~ \n</td></tr><tr><td>\n  \na slice object\n</td><td>\n  \n~~~ts\n{\n  initialArg?: K | T;\n  init?: (initialArg: K) => T;\n  reducer?: (state: T, action: any) => T;\n  isGetInitialStateFromStorage?: boolean;\n  middleware?: ((dispatch: Dispatch) => (next: Dispatch) => (action: any) => any)[];\n} | {\n  initialState: NonUndefined<T>;\n  reducers: {\n    [x: string]: {\n      (state: T, action: any): void | T;\n    };\n  };\n}\n~~~ \n</td><td>\n  \nA slice object is an object which its possible keys are for a React Context slice: *initialArg*, *init*, *reducer*, *isGetInitialStateFromStorage*, and *middleware*; and for a Redux slice: *reducers*, and *initialState*. The keys for a React Context slice are all optional. What makes a slice to be a Redux slice is the presence of the *reducers* key. If it's not present, then it is a React Context slice.\n</td><td>\n  \n~~~js\n{} // React Context slice\n~~~ \n</td></tr><tr><td>\n  \n*initialArg*\n</td><td>\n  \n~~~ts\nK | T;\n~~~\n</td><td>\n  \nIt's the argument passed to the *init* function to compute the initial state. If no *init* function is present in the definition of the slice, then it becomes the initial state. Used in React Context slices.\n</td><td>\n  \n~~~js\n{ \n  // React Context slice\n  initialArg: 0;\n}\n~~~\n</td></tr><tr><td>\n  \n*init*\n</td><td>\n  \n~~~ts\n(initialArg: K) => T;\n~~~\n</td><td>\n  \nIt's the function used to compute initial state of the slice. It takes *initialArg* as an argument. If no present then *initialArg* it's the initial state. Used in React Context slices.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  init: () => 0;\n}\n~~~\n</td></tr><tr><td>\n  \n*reducer*\n</td><td>\n  \n~~~ts\n(state: T, action: any) => T;\n~~~ \n</td><td>\n  \nIf a reducer is supplied in the definition of a React Context slice, then the *useSlice*, when used with this slice, will return a dispatch function as a second value in the array. If it is not defined, then the *useSlice* hook will return, for this slice, a setter function as a second value in the array.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  reducer: (state) => !state;\n}\n~~~\n</td></tr><tr><td>\n  \n*isGetInitialStateFromStorage*\n</td><td>\n  \n~~~ts\nboolean;\n~~~ \n</td><td>\n  \nIndicates whether the initial state for the slice will be recovered from local storage (web) or Async Storage (React Native). Used in React Context slices.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  isGetInitialStateFromStorage: true;\n}\n~~~\n</td></tr><tr><td>\n  \n*middleware*\n</td><td>\n  \n~~~ts\n((dispatch: Dispatch) => (next: Dispatch) => (action: any) => any)[];\n~~~\n</td><td>\n  \nIt's an array where the middleware for the dispatch function is passed. The first middleware applied will be the first on the array, the second the next, etc, ending with the dispatch function itself. The middleware does not have access to the state value of the slice. Used in React Context slices. \n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  middleware: [\n    () => (next) => (action) => {\n      console.log(\"I am a middleware\");\n      next(action);\n    },\n    (dispatch) => (next) => (action) => {\n      if (typeof action === \"function\") {\n        return action(dispatch);\n      }\n      next(action);\n    },\n  ];\n}\n~~~\n</td></tr><tr><td>\n  \n*reducers*\n</td><td>\n  \n~~~ts\n{\n  [x: string]: {\n    (state: T, action: any): void | T;\n  };\n}\n~~~ \n</td><td>\n  \nWhen this key is present in the definition of a slice object, then the slice it's a Redux slice. Otherwise it's a React Context slice. It's the *reducers* object passed to the *createSlice* from Redux Toolkit (check the documentation there). \n</td><td>\n  \n~~~js\n{\n  // Redux slice\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1\n  }\n}\n~~~ \n</td></tr><tr><td>\n  \n*initialState*\n</td><td>\n  \n~~~ts\nT extends undefined ? never : T;\n~~~ \n</td><td>\n  \nUsed for Redux slices. It's the initial state for the slice. Cannot be *undefined* (make it *null* instead). \n</td><td>\n  \n~~~js\n{\n  // Redux slice\n  initialState: [],\n  reducers: {\n    add: (state, {payload}) => {\n      state.push(payload);\n    }\n  }\n}\n~~~\n</td></tr><tr><td>\n  \n*useSlice* \n</td><td>\n  \n~~~ts\n(<T, K = T>(\n    slice: string,\n    selector: (state: T) => K\n  ) => [K, ReduxDispatch<AnyAction>, { [x: string]: any }]) &\n    (<T>(\n      slice: string\n    ) => [\n      T,\n      SetValue<T> & Dispatch & ReduxDispatch<AnyAction>,\n      { [x: string]: any }\n    ]);\n~~~ \n</td><td>\n  \nIt's the hook returned by the call to *getHookAndProviderFromSlices*. When used, you must pass the name of the slice you want to fetch or use. It will return, in the case of a React Context slice, an array where the first element is the state value of the slice and the second a dispatch or setter function, depending on if a reducer was defined or not for the slice. In the case of Redux slices, you can pass a selector as a second parameter to the call of the *useSlice* hook. It will return an array where the first element is the state value for the slice (with the selector applied, if any), the second element is the dispatch function, and the third element is the actions object (action creators) for the slice. \n</td><td>\n  \n~~~js\nconst [count1, setCount1] = useSlice(\"count1\");\nconst [count2, dispatchCount2] = useSlice(\"count2\");\nconst [count3, reduxDispatch, { increment, decrement }] = useSlice(\"count3\");\nconst [todos,, { add }] = useSlice(\"todos\"); // reduxDispatch is common for all Redux slices\nconst [firstTodo] = useSlice(\"todos\", (state) => state[0]);\n~~~\n</td></tr><tr><td>\n  \n*Provider*\n</td><td>\n  \n~~~ts\n({ children }: React.PropsWithChildren) => JSX.Element;\n~~~ \n</td><td>\n  \nIt's the provider returned by the call to *getHookAndProviderFromSlices*. It must be used up in the tree, in order for the hook *useSlice* to work. \n</td><td>\n  \n~~~js\nroot.render(\n  <Provider>\n    <App />\n  </Provider>\n);\n~~~\n</td></tr>\n</table>\n"}]}]]}],null],"segment":"__PAGE__"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c580934e13ef668d.css","precedence":"next"}]]}],"segment":"api-reference"},"styles":[]}]}]]}]}],["$","$La",null,{"maxWidth":849,"children":["$","div",null,{"className":"layout_appContainer__lBmos layout_mobileAppContainer__76fVW","children":[["$","$Le",null,{}],["$","div",null,{"className":"layout_mobilePageContent__Jc17u","children":[["$","$Lf",null,{}],["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(layout)","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(layout)","children","api-reference","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[["$","$Lc",null,{"children":[["$","$Ld",null,{"children":"The library exports two functions and a typescript type: *getHookAndProviderFromSlices*, *defineSlice*, and *ReduxMiddleware*. *getHookAndProviderFromSlices* is the main function exported and it's a default export. *defineSlice* it's a function only used in typescript."}],["$","div",null,{"children":["$","$Ld",null,{"className":"page_table__6JVk5","children":"\n<table><tr><th>Name</th><th>Type</th><th style=\"min-width:400px;\">Description</th><th>Example</th></tr>\n<tr><td>\n  \n  *getHookAndProviderFromSlices* (default import)</td><td>\n\n ~~~ts\n (config: {\n  slices?: {\n    [slice: string]: Slice<any, any>;\n  };\n  AsyncStorage?: any;\n  reduxStoreOptions?: {\n    middleware:\n      | ((getDefaultMiddleware: any) => MiddlewareArray)\n      | MiddlewareArray;\n  };\n}) => {\n  useSlice: (<T, K = T>(\n    slice: string,\n    selector: (state: T) => K\n  ) => [K, ReduxDispatch<AnyAction>, { [x: string]: any }]) &\n    (<T, K = T>(\n      slice: string\n    ) => [\n      K,\n      SetValue<T> & Dispatch & ReduxDispatch<AnyAction>,\n      { [x: string]: any }\n    ]);\n  Provider: ContextProviderType;\n}\n ~~~\n  </td><td>\n    \n  It is the main (and default) function exported by the library. You pass a config object with optional keys *slices*, *AsyncStorage*, and *reduxStoreOptions*. The *slices* key is an object wich its keys are the slices names and its values, the defintion of the slices.</td><td>\n    \n~~~js\nimport getHookAndProviderFromSlices from \"react-context-slices\";\n\nexport const { useSlice, Provider } = getHookAndProviderFromSlices({\n  slices: {\n    count: { initialArg: 0 }, // React Context slice\n  },\n});\n~~~\n</td></tr><tr><td>\n\n*defineSlice* (used in typescript)\n  </td><td>\n    \n~~~ts\n<T, K = T>(slice: Slice<T, K>) => Slice<T, K>;\n~~~\n</td><td>\n  \n  This function enforces rules for types in the definition of a slice object. It's a generic function.</td><td>\n    \n~~~ts\nimport getHookAndProviderFromSlices, {defineSlice} from \"react-context-slices\";\n\nexport const { useSlice, Provider } = getHookAndProviderFromSlices({\n  slices: {\n    count: defineSlice<number>({ initialArg: 0 }), // React Context slice\n  },\n});\n~~~\n</td></tr><tr><td>\n  \n*ReduxMiddleware* (typescript type)\n</td><td>\n  \n~~~ts\n(store: {\n  getState: () => any;\n  dispatch: ReduxDispatch<AnyAction>;\n}) => (next: ReduxDispatch<AnyAction>) => (action: AnyAction) => void;\n~~~\n</td><td>\n  \nIs the type against to make an assertion in typescript when defining middleware in *reduxStoreOptions*\n</td><td>\n  \n~~~ts\nimport getHookAndProviderFromSlices, {defineSlice, ReduxMiddleware} from \"react-context-slices\";\n\nexport const {useSlice, Provider} = getHookAndProviderFromSlices({\n  slices:{\n    //...\n  },\n  reduxStoreOptions: {\n    middleware: (getDefaultMiddleware) =>\n      getDefaultMiddleware().concat(((store) => (next) => (action) => {\n        //...\n      }) as ReduxMiddleware);\n  }\n});\n~~~\n</td></tr>\n</table>\n"}]}],["$","$Ld",null,{"children":"Next are described other entities encountered when using this library."}],["$","div",null,{"children":["$","$Ld",null,{"className":"page_table__6JVk5","children":"\n<table><tr><th>Name</th><th>Type</th><th style=\"min-width:400px;\">Description</th><th>Example</th></tr>\n<tr><td>config object</td><td>\n  \n~~~ts\n{\n  slices?: {\n    [slice: string]: Slice<any, any>;\n  };\n  AsyncStorage?: any;\n  reduxStoreOptions?: {\n    middleware?:\n      | ((getDefaultMiddleware: any) => MiddlewareArray)\n      | MiddlewareArray;\n    devTools?: any;\n    preloadedState?: any;\n    enhancers?: any;\n  };\n}\n~~~\n</td><td>\n  \nIt's the object passed to *getHookAndProviderFromSlices*. It can contain three optional keys: *slices*, *AsyncStorage*, and *reduxStoreOptions*.\n</td><td>\n  \n~~~js\n{\n  slices: {\n    //...\n  }\n}\n~~~\n</td></tr><tr><td>\n  \nslices object\n</td><td>\n  \n~~~ts\n{\n  [name:string]: Slice<T, K>;\n}\n~~~ \n</td><td>\n  \nThe slices object is an object which its keys are the name of the slices and its values are the slices themselves.\n</td><td>\n  \n~~~js\n{\n  count: {initialArg: 0}, // React Context slice\n  todos: { \n    // Redux slice\n    initialState: [],\n    reducers: {\n      add: (state, {payload}) => {\n        state.push(payload);\n      }\n    }\n  }\n}\n~~~ \n</td></tr><tr><td>\n  \na slice object\n</td><td>\n  \n~~~ts\n{\n  initialArg?: K | T;\n  init?: (initialArg: K) => T;\n  reducer?: (state: T, action: any) => T;\n  isGetInitialStateFromStorage?: boolean;\n  middleware?: ((dispatch: Dispatch) => (next: Dispatch) => (action: any) => any)[];\n} | {\n  initialState: NonUndefined<T>;\n  reducers: {\n    [x: string]: {\n      (state: T, action: any): void | T;\n    };\n  };\n}\n~~~ \n</td><td>\n  \nA slice object is an object which its possible keys are for a React Context slice: *initialArg*, *init*, *reducer*, *isGetInitialStateFromStorage*, and *middleware*; and for a Redux slice: *reducers*, and *initialState*. The keys for a React Context slice are all optional. What makes a slice to be a Redux slice is the presence of the *reducers* key. If it's not present, then it is a React Context slice.\n</td><td>\n  \n~~~js\n{} // React Context slice\n~~~ \n</td></tr><tr><td>\n  \n*initialArg*\n</td><td>\n  \n~~~ts\nK | T;\n~~~\n</td><td>\n  \nIt's the argument passed to the *init* function to compute the initial state. If no *init* function is present in the definition of the slice, then it becomes the initial state. Used in React Context slices.\n</td><td>\n  \n~~~js\n{ \n  // React Context slice\n  initialArg: 0;\n}\n~~~\n</td></tr><tr><td>\n  \n*init*\n</td><td>\n  \n~~~ts\n(initialArg: K) => T;\n~~~\n</td><td>\n  \nIt's the function used to compute initial state of the slice. It takes *initialArg* as an argument. If no present then *initialArg* it's the initial state. Used in React Context slices.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  init: () => 0;\n}\n~~~\n</td></tr><tr><td>\n  \n*reducer*\n</td><td>\n  \n~~~ts\n(state: T, action: any) => T;\n~~~ \n</td><td>\n  \nIf a reducer is supplied in the definition of a React Context slice, then the *useSlice*, when used with this slice, will return a dispatch function as a second value in the array. If it is not defined, then the *useSlice* hook will return, for this slice, a setter function as a second value in the array.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  reducer: (state) => !state;\n}\n~~~\n</td></tr><tr><td>\n  \n*isGetInitialStateFromStorage*\n</td><td>\n  \n~~~ts\nboolean;\n~~~ \n</td><td>\n  \nIndicates whether the initial state for the slice will be recovered from local storage (web) or Async Storage (React Native). Used in React Context slices.\n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  isGetInitialStateFromStorage: true;\n}\n~~~\n</td></tr><tr><td>\n  \n*middleware*\n</td><td>\n  \n~~~ts\n((dispatch: Dispatch) => (next: Dispatch) => (action: any) => any)[];\n~~~\n</td><td>\n  \nIt's an array where the middleware for the dispatch function is passed. The first middleware applied will be the first on the array, the second the next, etc, ending with the dispatch function itself. The middleware does not have access to the state value of the slice. Used in React Context slices. \n</td><td>\n  \n~~~js\n{\n  // React Context slice\n  middleware: [\n    () => (next) => (action) => {\n      console.log(\"I am a middleware\");\n      next(action);\n    },\n    (dispatch) => (next) => (action) => {\n      if (typeof action === \"function\") {\n        return action(dispatch);\n      }\n      next(action);\n    },\n  ];\n}\n~~~\n</td></tr><tr><td>\n  \n*reducers*\n</td><td>\n  \n~~~ts\n{\n  [x: string]: {\n    (state: T, action: any): void | T;\n  };\n}\n~~~ \n</td><td>\n  \nWhen this key is present in the definition of a slice object, then the slice it's a Redux slice. Otherwise it's a React Context slice. It's the *reducers* object passed to the *createSlice* from Redux Toolkit (check the documentation there). \n</td><td>\n  \n~~~js\n{\n  // Redux slice\n  initialState: 0,\n  reducers: {\n    increment: (state) => state + 1,\n    decrement: (state) => state - 1\n  }\n}\n~~~ \n</td></tr><tr><td>\n  \n*initialState*\n</td><td>\n  \n~~~ts\nT extends undefined ? never : T;\n~~~ \n</td><td>\n  \nUsed for Redux slices. It's the initial state for the slice. Cannot be *undefined* (make it *null* instead). \n</td><td>\n  \n~~~js\n{\n  // Redux slice\n  initialState: [],\n  reducers: {\n    add: (state, {payload}) => {\n      state.push(payload);\n    }\n  }\n}\n~~~\n</td></tr><tr><td>\n  \n*useSlice* \n</td><td>\n  \n~~~ts\n(<T, K = T>(\n    slice: string,\n    selector: (state: T) => K\n  ) => [K, ReduxDispatch<AnyAction>, { [x: string]: any }]) &\n    (<T>(\n      slice: string\n    ) => [\n      T,\n      SetValue<T> & Dispatch & ReduxDispatch<AnyAction>,\n      { [x: string]: any }\n    ]);\n~~~ \n</td><td>\n  \nIt's the hook returned by the call to *getHookAndProviderFromSlices*. When used, you must pass the name of the slice you want to fetch or use. It will return, in the case of a React Context slice, an array where the first element is the state value of the slice and the second a dispatch or setter function, depending on if a reducer was defined or not for the slice. In the case of Redux slices, you can pass a selector as a second parameter to the call of the *useSlice* hook. It will return an array where the first element is the state value for the slice (with the selector applied, if any), the second element is the dispatch function, and the third element is the actions object (action creators) for the slice. \n</td><td>\n  \n~~~js\nconst [count1, setCount1] = useSlice(\"count1\");\nconst [count2, dispatchCount2] = useSlice(\"count2\");\nconst [count3, reduxDispatch, { increment, decrement }] = useSlice(\"count3\");\nconst [todos,, { add }] = useSlice(\"todos\"); // reduxDispatch is common for all Redux slices\nconst [firstTodo] = useSlice(\"todos\", (state) => state[0]);\n~~~\n</td></tr><tr><td>\n  \n*Provider*\n</td><td>\n  \n~~~ts\n({ children }: React.PropsWithChildren) => JSX.Element;\n~~~ \n</td><td>\n  \nIt's the provider returned by the call to *getHookAndProviderFromSlices*. It must be used up in the tree, in order for the hook *useSlice* to work. \n</td><td>\n  \n~~~js\nroot.render(\n  <Provider>\n    <App />\n  </Provider>\n);\n~~~\n</td></tr>\n</table>\n"}]}]]}],null],"segment":"__PAGE__"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c580934e13ef668d.css","precedence":"next"}]]}],"segment":"api-reference"},"styles":[]}]]}]]}]}]],null],"segment":"(layout)"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/96e77edbf29b84fb.css","precedence":"next"}]]}]}]}]}]]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"react-context-slices"}],["$","meta","2",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]]
